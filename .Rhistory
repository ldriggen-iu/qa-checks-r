# Notes: As long as the working directory structure
# matches README.md, such that the data tables,
# R-code, and resources may be sourced,
# then this code should run smoothly, generating
# a listing of data queries in /output.
#
# Created: 9 November 2012
# Revisions: 24 February 2016 Larry Riggen added code for
#            tblDELIVERY_CHILD, ???? complete list when all new
#            tables are defined ????
#            added code to process North America (NA) region codes
#            as text instead of missing values.
#
#
#############################################################
rm(list=ls()) # clear namespace
## USER -- PLEASE REVISE or CHANGE THE APPROPRIATE WORKING DIRECTORY AND SET THE APPROPRIATE DATABASE CLOSE DATE
setwd("I:/Projects/IeDEA/Grants/Yiannoutsos/BD2K/IeDEA_DES/GitRepository")
## IN ORDER TO ASSESS DATES OCCURRING IN THE FUTURE, WE NEED A DATABASE CLOSE DATE (YYYY-MM-DD)
databaseclose <- "2013-12-01"
## READ QUERY_FUNCTIONS.R
source("code/query_functions.R")
## INDEX NUMBER FOR QUERY FILES
index <- 1
## EMPTY MATRIX FOR ALL QUERIES and ALL CHECKS
emptyquery <- data.frame(PID=character(),Table=character(),Variable=character(),Error=character(),Query=character(),Info=character())
allcheck <- NULL
## CONVERT DATABASE CLOSE TO DATE FORMAT, IF MISSING/INCORRECT, THEN USE SYSTEM DATE (TODAY)
databaseclose <- as.Date(databaseclose,"%Y-%m-%d")
databaseclose <- ifelse(is.na(databaseclose),Sys.Date(),databaseclose)
## IDENTIFY WHICH TABLES TO EXPECT FROM DES
expectedtables <- c("center","program","basic","ltfu","cd4","rna","bp","viro","res","reslvl2","reslvl3","art","med",
"dis","distb","visit","deliverychild","deliverymum","lab","canc","cep","newborn","newbornabnorm","pregout","preg","artmum")
expecteddestables <- c("tblCENTER","tblPROGRAM","tblBAS","tblLTFU","tblLAB_CD4","tblLAB_RNA","tblLAB_BP","tblLAB_VIRO","tblLAB_RES","tblLAB_RES_LVL_2","tblLAB_RES_LVL_3","tblART","tblMED","tblDIS","tblDIS_TB","tblVIS",
"tblDELIVERY_CHILD","tblDELIVERY_MUM","tblLAB","tblCANC","tblCEP","tblNEWBORN","tblNEWBORN_ABNORM","tblPREG_OUT","tblPREG","tblART_MUM")
## CHOOSE FIRST SELECTS THE TEXT STRING OCCURING BEFORE THE SPECIFIED SEPARATER
choosefirst <- function(var,sep=".") unlist(lapply(strsplit(var,sep,fixed=TRUE),function(x) x[1]))
## DETERMINE WHICH TABLES EXIST IN '/input'
existingtables <- choosefirst(list.files("input"))
readtables <- expectedtables[match(existingtables,expecteddestables)]
## READ IN ALL EXISTING TABLES
## ???? LDR original code
#for(i in 1:length(readtables)){
#  if(!is.na(readtables[i])){
#     readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
#     names(readcsv) <- tolower(names(readcsv))
#     assign(readtables[i],readcsv)
#   }
#}
## ???? LDR code to handle "NA" North America region code as text instead of missing values
for(i in 1:length(readtables)){
if(!is.na(readtables[i])){
if (readtables[i] == "center" || readtables[i]== "program")  {
# read the table in with na.strings=c("") to pick up the region as text
read1 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(""))
names(read1) <- tolower(names(read1))
read2 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(read2) <- tolower(names(read2))
center_region<-subset(read1,select=c("region"))
center_rest<-subset(read1,select= - region)
readcsv<-cbind(center_region,center_rest)
assign(readtables[i],readcsv)
}
else {
readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(readcsv) <- tolower(names(readcsv))
assign(readtables[i],readcsv)
}
}
}
#############################################################
#
#   Program: tblLAB_VIRO_checks.R
#   Project: IeDEA
#
#   PI: Stephany Duda, PhD
#   Programmer: Larry Riggen, MS
#   Purpose: Read in IeDEAS standard and write
#            data queries
#
#   INPUT: "tblLAB_VIRO.csv"
#   OUTPUT:
#
#   Notes: As long as the working directory in "setwd" is
#          correctly pointing to the location of tblLAB_VIRO.csv,
#          then this code should run smoothly, generating
#          a listing of data queries.
#
#   Created: 01 March 2016
#   Revisions:
#
#############################################################
## NAME OF TABLE FOR WRITING QUERIES
tablename <- "tblLAB_VIRO"
## NAMES EXPECTED FROM HICDEP+/IeDEAS DES
expectednames <- c("patient","vs_id","vs_d","vs_r","vs_v","vs_u","vs_st")
acceptablenames <- c(expectednames,"vs_d_a")
################### QUERY CHECKING BEGINS HERE ###################
## CHECK FOR EXTRA OR MISSING VARIABLES
extravar(acceptablenames,viro)
missvar(expectednames,viro)
## PRIOR TO CONVERTING DATES, CHECK THAT THE TYPE IS APPROPRIATE
notdate(vs_d,viro,id=patient)
##??? require all variables to be present (even _A's)
## CHECK FOR MISSING DATA
#missingvalue(art_id,deliverychild)
#missingvalue(art_sd,deliverychild)
## CONVERT DATES USING EXPECTED FORMAT (will force NA if format is incorrect)
viro$vs_d <- convertdate(vs_d,viro)
## CHECK FOR DATES OCCURRING IN THE WRONG ORDER
if(exists("basic")){
basviro <- merge(viro,with(basic,data.frame(patient,birth_d)),all.x=TRUE)
basviro$birth_d <- convertdate(birth_d,basviro)
outoforder(birth_d,vs_d,basviro,table2="tblBAS")
}
if(exists("ltfu")){
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,death_d)),all.x=TRUE)
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
outoforder(vs_d,death_d,ltfuviro,table2="tblLTFU")
}
View(query4)
View(query4)
if(exists("ltfu")){
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,death_d)),all.x=TRUE)
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
outoforder(vs_d,death_d,ltfuviro,table2="tblLTFU")
ltfuviro$l_alive_d <- convertdate(l_alive_d,ltfuviro)
outoforder(vs_d,l_alive_d,ltfuviro,table2="tblLTFU")
}
#############################################################
#
# Program: tbl_checks.R
# Project: IeDEA
#
# Biostatistician/Programmer: Meridith Blevins, MS
# Purpose: Read in IeDEAS standard and write
# data queries
#
# INPUT: "tblXXX.csv", "tblXXX_checks.R"
# OUTPUT: "tbl_query_yyyymmdd.csv"
#
# Notes: As long as the working directory structure
# matches README.md, such that the data tables,
# R-code, and resources may be sourced,
# then this code should run smoothly, generating
# a listing of data queries in /output.
#
# Created: 9 November 2012
# Revisions: 24 February 2016 Larry Riggen added code for
#            tblDELIVERY_CHILD, ???? complete list when all new
#            tables are defined ????
#            added code to process North America (NA) region codes
#            as text instead of missing values.
#
#
#############################################################
rm(list=ls()) # clear namespace
## USER -- PLEASE REVISE or CHANGE THE APPROPRIATE WORKING DIRECTORY AND SET THE APPROPRIATE DATABASE CLOSE DATE
setwd("I:/Projects/IeDEA/Grants/Yiannoutsos/BD2K/IeDEA_DES/GitRepository")
## IN ORDER TO ASSESS DATES OCCURRING IN THE FUTURE, WE NEED A DATABASE CLOSE DATE (YYYY-MM-DD)
databaseclose <- "2013-12-01"
## READ QUERY_FUNCTIONS.R
source("code/query_functions.R")
## INDEX NUMBER FOR QUERY FILES
index <- 1
## EMPTY MATRIX FOR ALL QUERIES and ALL CHECKS
emptyquery <- data.frame(PID=character(),Table=character(),Variable=character(),Error=character(),Query=character(),Info=character())
allcheck <- NULL
## CONVERT DATABASE CLOSE TO DATE FORMAT, IF MISSING/INCORRECT, THEN USE SYSTEM DATE (TODAY)
databaseclose <- as.Date(databaseclose,"%Y-%m-%d")
databaseclose <- ifelse(is.na(databaseclose),Sys.Date(),databaseclose)
## IDENTIFY WHICH TABLES TO EXPECT FROM DES
expectedtables <- c("center","program","basic","ltfu","cd4","rna","bp","viro","res","reslvl2","reslvl3","art","med",
"dis","distb","visit","deliverychild","deliverymum","lab","canc","cep","newborn","newbornabnorm","pregout","preg","artmum")
expecteddestables <- c("tblCENTER","tblPROGRAM","tblBAS","tblLTFU","tblLAB_CD4","tblLAB_RNA","tblLAB_BP","tblLAB_VIRO","tblLAB_RES","tblLAB_RES_LVL_2","tblLAB_RES_LVL_3","tblART","tblMED","tblDIS","tblDIS_TB","tblVIS",
"tblDELIVERY_CHILD","tblDELIVERY_MUM","tblLAB","tblCANC","tblCEP","tblNEWBORN","tblNEWBORN_ABNORM","tblPREG_OUT","tblPREG","tblART_MUM")
## CHOOSE FIRST SELECTS THE TEXT STRING OCCURING BEFORE THE SPECIFIED SEPARATER
choosefirst <- function(var,sep=".") unlist(lapply(strsplit(var,sep,fixed=TRUE),function(x) x[1]))
## DETERMINE WHICH TABLES EXIST IN '/input'
existingtables <- choosefirst(list.files("input"))
readtables <- expectedtables[match(existingtables,expecteddestables)]
## READ IN ALL EXISTING TABLES
## ???? LDR original code
#for(i in 1:length(readtables)){
#  if(!is.na(readtables[i])){
#     readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
#     names(readcsv) <- tolower(names(readcsv))
#     assign(readtables[i],readcsv)
#   }
#}
## ???? LDR code to handle "NA" North America region code as text instead of missing values
for(i in 1:length(readtables)){
if(!is.na(readtables[i])){
if (readtables[i] == "center" || readtables[i]== "program")  {
# read the table in with na.strings=c("") to pick up the region as text
read1 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(""))
names(read1) <- tolower(names(read1))
read2 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(read2) <- tolower(names(read2))
center_region<-subset(read1,select=c("region"))
center_rest<-subset(read1,select= - region)
readcsv<-cbind(center_region,center_rest)
assign(readtables[i],readcsv)
}
else {
readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(readcsv) <- tolower(names(readcsv))
assign(readtables[i],readcsv)
}
}
}
#############################################################
#
#   Program: tblLAB_VIRO_checks.R
#   Project: IeDEA
#
#   PI: Stephany Duda, PhD
#   Programmer: Larry Riggen, MS
#   Purpose: Read in IeDEAS standard and write
#            data queries
#
#   INPUT: "tblLAB_VIRO.csv"
#   OUTPUT:
#
#   Notes: As long as the working directory in "setwd" is
#          correctly pointing to the location of tblLAB_VIRO.csv,
#          then this code should run smoothly, generating
#          a listing of data queries.
#
#   Created: 01 March 2016
#   Revisions:
#
#############################################################
## NAME OF TABLE FOR WRITING QUERIES
tablename <- "tblLAB_VIRO"
## NAMES EXPECTED FROM HICDEP+/IeDEAS DES
expectednames <- c("patient","vs_id","vs_d","vs_r","vs_v","vs_u","vs_st")
acceptablenames <- c(expectednames,"vs_d_a")
################### QUERY CHECKING BEGINS HERE ###################
## CHECK FOR EXTRA OR MISSING VARIABLES
extravar(acceptablenames,viro)
missvar(expectednames,viro)
## PRIOR TO CONVERTING DATES, CHECK THAT THE TYPE IS APPROPRIATE
notdate(vs_d,viro,id=patient)
##??? require all variables to be present (even _A's)
## CHECK FOR MISSING DATA
#missingvalue(art_id,deliverychild)
#missingvalue(art_sd,deliverychild)
## CONVERT DATES USING EXPECTED FORMAT (will force NA if format is incorrect)
viro$vs_d <- convertdate(vs_d,viro)
## CHECK FOR DATES OCCURRING IN THE WRONG ORDER
if(exists("basic")){
basviro <- merge(viro,with(basic,data.frame(patient,birth_d)),all.x=TRUE)
basviro$birth_d <- convertdate(birth_d,basviro)
outoforder(birth_d,vs_d,basviro,table2="tblBAS")
}
if(exists("ltfu")){
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,death_d)),all.x=TRUE)
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
outoforder(vs_d,death_d,ltfuviro,table2="tblLTFU")
ltfuviro$l_alive_d <- convertdate(l_alive_d,ltfuviro)
outoforder(vs_d,l_alive_d,ltfuviro,table2="tblLTFU")
}
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,death_d)),all.x=TRUE)
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
outoforder(vs_d,death_d,ltfuviro,table2="tblLTFU")
ltfuviro$l_alive_d <- convertdate(l_alive_d,ltfuviro)
outoforder(vs_d,l_alive_d,ltfuviro,table2="tblLTFU")
#############################################################
#
# Program: tbl_checks.R
# Project: IeDEA
#
# Biostatistician/Programmer: Meridith Blevins, MS
# Purpose: Read in IeDEAS standard and write
# data queries
#
# INPUT: "tblXXX.csv", "tblXXX_checks.R"
# OUTPUT: "tbl_query_yyyymmdd.csv"
#
# Notes: As long as the working directory structure
# matches README.md, such that the data tables,
# R-code, and resources may be sourced,
# then this code should run smoothly, generating
# a listing of data queries in /output.
#
# Created: 9 November 2012
# Revisions: 24 February 2016 Larry Riggen added code for
#            tblDELIVERY_CHILD, ???? complete list when all new
#            tables are defined ????
#            added code to process North America (NA) region codes
#            as text instead of missing values.
#
#
#############################################################
rm(list=ls()) # clear namespace
## USER -- PLEASE REVISE or CHANGE THE APPROPRIATE WORKING DIRECTORY AND SET THE APPROPRIATE DATABASE CLOSE DATE
setwd("I:/Projects/IeDEA/Grants/Yiannoutsos/BD2K/IeDEA_DES/GitRepository")
## IN ORDER TO ASSESS DATES OCCURRING IN THE FUTURE, WE NEED A DATABASE CLOSE DATE (YYYY-MM-DD)
databaseclose <- "2013-12-01"
## READ QUERY_FUNCTIONS.R
source("code/query_functions.R")
## INDEX NUMBER FOR QUERY FILES
index <- 1
## EMPTY MATRIX FOR ALL QUERIES and ALL CHECKS
emptyquery <- data.frame(PID=character(),Table=character(),Variable=character(),Error=character(),Query=character(),Info=character())
allcheck <- NULL
## CONVERT DATABASE CLOSE TO DATE FORMAT, IF MISSING/INCORRECT, THEN USE SYSTEM DATE (TODAY)
databaseclose <- as.Date(databaseclose,"%Y-%m-%d")
databaseclose <- ifelse(is.na(databaseclose),Sys.Date(),databaseclose)
## IDENTIFY WHICH TABLES TO EXPECT FROM DES
expectedtables <- c("center","program","basic","ltfu","cd4","rna","bp","viro","res","reslvl2","reslvl3","art","med",
"dis","distb","visit","deliverychild","deliverymum","lab","canc","cep","newborn","newbornabnorm","pregout","preg","artmum")
expecteddestables <- c("tblCENTER","tblPROGRAM","tblBAS","tblLTFU","tblLAB_CD4","tblLAB_RNA","tblLAB_BP","tblLAB_VIRO","tblLAB_RES","tblLAB_RES_LVL_2","tblLAB_RES_LVL_3","tblART","tblMED","tblDIS","tblDIS_TB","tblVIS",
"tblDELIVERY_CHILD","tblDELIVERY_MUM","tblLAB","tblCANC","tblCEP","tblNEWBORN","tblNEWBORN_ABNORM","tblPREG_OUT","tblPREG","tblART_MUM")
## CHOOSE FIRST SELECTS THE TEXT STRING OCCURING BEFORE THE SPECIFIED SEPARATER
choosefirst <- function(var,sep=".") unlist(lapply(strsplit(var,sep,fixed=TRUE),function(x) x[1]))
## DETERMINE WHICH TABLES EXIST IN '/input'
existingtables <- choosefirst(list.files("input"))
readtables <- expectedtables[match(existingtables,expecteddestables)]
## READ IN ALL EXISTING TABLES
## ???? LDR original code
#for(i in 1:length(readtables)){
#  if(!is.na(readtables[i])){
#     readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
#     names(readcsv) <- tolower(names(readcsv))
#     assign(readtables[i],readcsv)
#   }
#}
## ???? LDR code to handle "NA" North America region code as text instead of missing values
for(i in 1:length(readtables)){
if(!is.na(readtables[i])){
if (readtables[i] == "center" || readtables[i]== "program")  {
# read the table in with na.strings=c("") to pick up the region as text
read1 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(""))
names(read1) <- tolower(names(read1))
read2 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(read2) <- tolower(names(read2))
center_region<-subset(read1,select=c("region"))
center_rest<-subset(read1,select= - region)
readcsv<-cbind(center_region,center_rest)
assign(readtables[i],readcsv)
}
else {
readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(readcsv) <- tolower(names(readcsv))
assign(readtables[i],readcsv)
}
}
}
#############################################################
#
#   Program: tblLAB_VIRO_checks.R
#   Project: IeDEA
#
#   PI: Stephany Duda, PhD
#   Programmer: Larry Riggen, MS
#   Purpose: Read in IeDEAS standard and write
#            data queries
#
#   INPUT: "tblLAB_VIRO.csv"
#   OUTPUT:
#
#   Notes: As long as the working directory in "setwd" is
#          correctly pointing to the location of tblLAB_VIRO.csv,
#          then this code should run smoothly, generating
#          a listing of data queries.
#
#   Created: 01 March 2016
#   Revisions:
#
#############################################################
## NAME OF TABLE FOR WRITING QUERIES
tablename <- "tblLAB_VIRO"
## NAMES EXPECTED FROM HICDEP+/IeDEAS DES
expectednames <- c("patient","vs_id","vs_d","vs_r","vs_v","vs_u","vs_st")
acceptablenames <- c(expectednames,"vs_d_a")
################### QUERY CHECKING BEGINS HERE ###################
## CHECK FOR EXTRA OR MISSING VARIABLES
extravar(acceptablenames,viro)
missvar(expectednames,viro)
## PRIOR TO CONVERTING DATES, CHECK THAT THE TYPE IS APPROPRIATE
notdate(vs_d,viro,id=patient)
##??? require all variables to be present (even _A's)
## CHECK FOR MISSING DATA
#missingvalue(art_id,deliverychild)
#missingvalue(art_sd,deliverychild)
## CONVERT DATES USING EXPECTED FORMAT (will force NA if format is incorrect)
viro$vs_d <- convertdate(vs_d,viro)
## CHECK FOR DATES OCCURRING IN THE WRONG ORDER
if(exists("basic")){
basviro <- merge(viro,with(basic,data.frame(patient,birth_d)),all.x=TRUE)
basviro$birth_d <- convertdate(birth_d,basviro)
outoforder(birth_d,vs_d,basviro,table2="tblBAS")
}
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
outoforder(vs_d,death_d,ltfuviro,table2="tblLTFU")
View(query3)
View(query3)
View(newborn)
View(lab)
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,death_d)),all.x=TRUE)
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
outoforder(vs_d,death_d,ltfuviro,table2="tblLTFU")
View(ltfuviro)
View(ltfuviro)
View(query4)
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,l_alive_d)),all.x=TRUE)
ltfuviro$l_alive_d <- convertdate(l_alive_d,ltfuviro)
outoforder(vs_d,l_alive_d,ltfuviro,table2="tblLTFU")
View(query5)
## CHECK FOR DATES OCCURRING IN THE WRONG ORDER
#outoforder(art_sd,art_ed,art)
## CHECK FOR DATES OCCURRING TOO FAR IN THE FUTURE
futuredate(vs_d,viro,id=patient)
## CHECK FOR INCORRECT VARIABLE TYPE (prior to range checks, if applicable)
notnumeric(vs_r,viro)
notnumeric(vs_u,viro)
##??? units on vs_u???
##??? range checks on vs_v - just for HVC-RNA and HBV-DNA???
## CHECK FOR UNEXPECTED CODING
vs_id_codebook <- read.csv("resource/vs_id_codebook.csv",header=TRUE,stringsAsFactors = FALSE,na.strings="")
View(vs_id_codebook)
#############################################################
#
#   Program: tblLAB_VIRO_checks.R
#   Project: IeDEA
#
#   PI: Stephany Duda, PhD
#   Programmer: Larry Riggen, MS
#   Purpose: Read in IeDEAS standard and write
#            data queries
#
#   INPUT: "tblLAB_VIRO.csv"
#   OUTPUT:
#
#   Notes: As long as the working directory in "setwd" is
#          correctly pointing to the location of tblLAB_VIRO.csv,
#          then this code should run smoothly, generating
#          a listing of data queries.
#
#   Created: 01 March 2016
#   Revisions:
#
#############################################################
## NAME OF TABLE FOR WRITING QUERIES
tablename <- "tblLAB_VIRO"
## NAMES EXPECTED FROM HICDEP+/IeDEAS DES
expectednames <- c("patient","vs_id","vs_d","vs_r","vs_v","vs_u","vs_st")
acceptablenames <- c(expectednames,"vs_d_a")
################### QUERY CHECKING BEGINS HERE ###################
## CHECK FOR EXTRA OR MISSING VARIABLES
extravar(acceptablenames,viro)
missvar(expectednames,viro)
## PRIOR TO CONVERTING DATES, CHECK THAT THE TYPE IS APPROPRIATE
notdate(vs_d,viro,id=patient)
##??? require all variables to be present (even _A's)
## CHECK FOR MISSING DATA
#missingvalue(art_id,deliverychild)
#missingvalue(art_sd,deliverychild)
## CONVERT DATES USING EXPECTED FORMAT (will force NA if format is incorrect)
viro$vs_d <- convertdate(vs_d,viro)
## CHECK FOR DATES OCCURRING IN THE WRONG ORDER
if(exists("basic")){
basviro <- merge(viro,with(basic,data.frame(patient,birth_d)),all.x=TRUE)
basviro$birth_d <- convertdate(birth_d,basviro)
outoforder(birth_d,vs_d,basviro,table2="tblBAS")
}
if(exists("ltfu")){
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,death_d)),all.x=TRUE)
ltfuviro$death_d <- convertdate(death_d,ltfuviro)
outoforder(vs_d,death_d,ltfuviro,table2="tblLTFU")
ltfuviro <- merge(viro,with(ltfu,data.frame(patient,l_alive_d)),all.x=TRUE)
ltfuviro$l_alive_d <- convertdate(l_alive_d,ltfuviro)
outoforder(vs_d,l_alive_d,ltfuviro,table2="tblLTFU")
}
## CHECK FOR DATES OCCURRING IN THE WRONG ORDER
#outoforder(art_sd,art_ed,art)
## CHECK FOR DATES OCCURRING TOO FAR IN THE FUTURE
futuredate(vs_d,viro,id=patient)
#??? need to add duplicate checks
## CHECK FOR DUPLICATE PATIENT IDs
#for(i in unique(art$art_id)[!is.na(unique(art$art_id))]){
#  art_sub <- art[art$id %in% i,]
#  queryduplicates(patient,art_sub,date=art_sd,subsettext=paste("&art_id=",i,sep=""))
#}
## CHECK FOR INCORRECT VARIABLE TYPE (prior to range checks, if applicable)
notnumeric(vs_r,viro)
notnumeric(vs_u,viro)
##??? units on vs_u???
##??? range checks on vs_v - just for HVC-RNA and HBV-DNA???
## CHECK FOR UNEXPECTED CODING
## ???? LDR - need to check with Bev and Stephany on final set of codes to be included in vs_id_codebook.
vs_id_codebook <- read.csv("resource/vs_id_codebook.csv",header=TRUE,stringsAsFactors = FALSE,na.strings="")
badcodes(vs_d_a,c("<",">","D","M","Y","U"),viro)
badcodes(vs_id,vs_id_codebook$code,viro)
badcodes(vs_st,c("WB","P","S","U24","U","CSF","9"),viro)
# ## NEED TO PROGRAM:
## ???? other checks ????
################### QUERY CHECKING ENDS HERE ###################
View(query9)
View(query8)
View(query10)
View(query11)
View(query12)
View(query13)
View(query14)
View(query15)
View(query16)
View(query17)
View(query18)
