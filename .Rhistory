unzip("H:/Chrome Downloads/care201610260340.zip",list=TRUE)
unzip("H:/Chrome Downloads/care201610260340.zip",files=c("care201610260340/ANAMMatch.csv",exdir="h:/"))
unzip("H:/Chrome Downloads/care201610260340.zip",files=c("ANAMMatch.csv",exdir="h:/"))
unzip("H:/Chrome Downloads/care201610260340.zip",files=c("ANAMMatch.csv"),exdir="h:/")
unzip("H:/Chrome Downloads/care201610260340.zip",files=c('care201610260340/ANAMMatch.csv'),exdir="h:/")
files_in_zip <-unzip("H:/Chrome Downloads/care201610260340.zip",list=TRUE)
View(files_in_zip)
View(files_in_zip)
class(files_in_zip)
for(i in 1:nrow(files_in_zip)) {
unzip("H:/Chrome Downloads/care201610260340.zip",files=files_in_zip$Name[i,],exdir="h:/")
}
for(i in 1:nrow(files_in_zip)) {
unzip("H:/Chrome Downloads/care201610260340.zip",files=files_in_zip[i,]$Name,exdir="h:/")
}
read.table("./input/tblART_required_columns.txt")
read.table("./input/tblART_required_columns.txt",header=FALSE,stringsAsFactors = FALSE)
#############################################################
#
# Program: tbl_checks.R
# Project: IeDEA
#
# Biostatistician/Programmer: Meridith Blevins, MS
# Purpose: Read in IeDEAS standard and write
# data queries
#
# INPUT: "tblXXX.csv", "tblXXX_checks.R"
# OUTPUT: "tbl_query_yyyymmdd.csv"
#
# Notes: As long as the working directory structure
# matches README.md, such that the data tables,
# R-code, and resources may be sourced,
# then this code should run smoothly, generating
# a listing of data queries in /output.
#
# Created: 9 November 2012
# Revisions: 24 February 2016 Larry Riggen added code for
#            tblDELIVERY_CHILD, ???? complete list when all new
#            tables are defined ????
#            added code to process North America (NA) region codes
#            as text instead of missing values.
#
#
#############################################################
rm(list=ls()) # clear namespace
## USER -- PLEASE REVISE or CHANGE THE APPROPRIATE WORKING DIRECTORY AND SET THE APPROPRIATE DATABASE CLOSE DATE
setwd("I:/Projects/IeDEA/Grants/Yiannoutsos/BD2K/IeDEA_DES/GitRepository")
## IN ORDER TO ASSESS DATES OCCURRING IN THE FUTURE, WE NEED A DATABASE CLOSE DATE (YYYY-MM-DD)
databaseclose <- "2013-12-01"
## READ QUERY_FUNCTIONS.R
source("code/query_functions.R")
## INDEX NUMBER FOR QUERY FILES
index <- 1
## EMPTY MATRIX FOR ALL QUERIES and ALL CHECKS
emptyquery <- data.frame(PID=character(),Table=character(),Variable=character(),Error=character(),Query=character(),Info=character())
allcheck <- NULL
## CONVERT DATABASE CLOSE TO DATE FORMAT, IF MISSING/INCORRECT, THEN USE SYSTEM DATE (TODAY)
databaseclose <- as.Date(databaseclose,"%Y-%m-%d")
databaseclose <- ifelse(is.na(databaseclose),Sys.Date(),databaseclose)
# ???? table tblCEP was dropped with the IeDEA_DES_Proposed_Additions_2016_Nov_14_V14.docx revision.
## IDENTIFY WHICH TABLES TO EXPECT FROM DES
expectedtables <- c("center","program","basic","ltfu","cd4","rna","bp","viro","res","reslvl2","reslvl3","art","med",
"dis","distb","visit","deliverychild","deliverymum","lab","canc","cep","newborn","newbornabnorm","pregout","preg","artmum")
expecteddestables <- c("tblCENTER","tblPROGRAM","tblBAS","tblLTFU","tblLAB_CD4","tblLAB_RNA","tblLAB_BP","tblLAB_VIRO","tblLAB_RES","tblLAB_RES_LVL_2","tblLAB_RES_LVL_3","tblART","tblMED","tblDIS","tblDIS_TB","tblVIS",
"tblDELIVERY_CHILD","tblDELIVERY_MUM","tblLAB","tblCANC","tblCEP","tblNEWBORN","tblNEWBORN_ABNORM","tblPREG_OUT","tblPREG","tblART_MUM")
## CHOOSE FIRST SELECTS THE TEXT STRING OCCURING BEFORE THE SPECIFIED SEPARATER
choosefirst <- function(var,sep=".") unlist(lapply(strsplit(var,sep,fixed=TRUE),function(x) x[1]))
## DETERMINE WHICH TABLES EXIST IN '/input'
existingtables <- choosefirst(list.files("input"))
readtables <- expectedtables[match(existingtables,expecteddestables)]
## READ IN ALL EXISTING TABLES
## ???? LDR original code
#for(i in 1:length(readtables)){
#  if(!is.na(readtables[i])){
#     readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
#     names(readcsv) <- tolower(names(readcsv))
#     assign(readtables[i],readcsv)
#   }
#}
## ???? LDR code to handle "NA" North America region code as text instead of missing values
for(i in 1:length(readtables)){
if(!is.na(readtables[i])){
if (readtables[i] == "center" || readtables[i]== "program")  {
# read the table in with na.strings=c("") to pick up the region as text
read1 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(""))
names(read1) <- tolower(names(read1))
read2 <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(read2) <- tolower(names(read2))
center_region<-subset(read1,select=c("region"))
center_rest<-subset(read1,select= - region)
readcsv<-cbind(center_region,center_rest)
assign(readtables[i],readcsv)
}
else {
readcsv <- read.csv(paste("input/",existingtables[i],".csv",sep=""),header=TRUE,stringsAsFactors = FALSE,na.strings=c(NA,""))
names(readcsv) <- tolower(names(readcsv))
assign(readtables[i],readcsv)
}
}
}
################### QUERY CHECK PROGRAMS BEGIN HERE #################
read.table("./input/tblART_required_columns.txt")
read.table("./input/tblART_required_columns.txt")
testread<-read.table("./input/tblART_required_columns.txt")
View(testread)
class(testread)
require(stringr)
testVector <- str_split(readLines("sample_text.txt"), pattern = " ")
readLines("./input/tblART_required_columns.txt"), pattern = " ")
readLines("./input/tblART_required_columns.txt")
read.table("./input/tblART_required_columns.txt")
read.table("./input/tblART_required_columns.txt",sep="")
read.table("./input/tblART_required_columns.txt",sep="")
test001<-read.table("./input/tblART_required_columns.txt",sep="")
class test001
class(test001)
test001{1,1}
test001[1,1]
test001[1,2]
test001<-read.table("./input/tblART_required_columns.txt",sep="", as.is)
test001<-read.table("./input/tblART_required_columns.txt",sep="", colClasses = "character" )
test001
test001<-scan("./input/tblART_required_columns.txt", )
test001<-scan("./input/tblART_required_columns.txt", )
test001<-scan("./input/tblART_required_columns.txt", sep="")
x <- scan("./input/tblART_required_columns.txt",nlines=1);
x <- scan("./input/tblART_required_columns.txt",nlines=1,what=list)
read.table("./input/Harmonist_required_columns.txt")
read.table("./input/Harmonist_required_columns.csv")
test001<-read.table("./input/Harmonist_required_columns.csv")
test001
test001<-read.table("./input/Harmonist_required_columns.csv",header = TRUE)
test001
test001<-read.table("./input/Harmonist_required_columns.csv",header = TRUE, sep="\t")
test001
test001<-read.table("./input/Harmonist_required_columns.csv",header = TRUE, sep="\t")
test001
View(test001)
test001<-read.table("./input/Harmonist_required_columns.csv",header = TRUE, sep="\t")
View(test001)
test001[1,]
test001[2,]
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t")
test001[2,]
test001[1,]
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t")
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t")
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t")
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t")
View(test001)
test001[1,]
test001[2,]
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t")
test001[2,]
View(test001)
View(test001)
test001[2,2]
test001[1,2]
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t")
View(test001)
View(test001)
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
View(test001)
View(test001)
View(test001)
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
View(test001)
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
tablename <- "tblART"
test001[,test001$tbl==tablename]$tbl
test001[,test001$tbl==tablename]$required_columns
test001[,tbl==tablename]$required_columns
test001[test001$tbl==tablename,]$required_columns
expectednames<-test001[test001$tbl==tablename,]$required_columns
expectednames
expectednames <- c("patient","art_id","art_sd","art_ed","art_rs","art_rs2","art_rs3","art_rs4","art_form","art_comb","artstart_rs")
expectednames
class(expectednames)
expectednames<-test001[test001$tbl==tablename,]$required_columns
class(expectednames)
class(expectednames)
expectednames
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
expectednames<-test001[test001$tbl==tablename,]$required_columns
expectednames
test001<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
expectednames
extravar(acceptablenames,art)
expectednames<-test001[test001$tbl==tablename,]$required_columns
expectednames
acceptablenames<-test001[test001$tbl==tablename,]$acceptable_columns
acceptablenames
if (file.exists("./input/Specification_of_required_and_acceptable_columns.csv")) {
## if the Specification file exists tbl_checks.R will only call tblART_checks.R
## when tblART has been specified as being in the set of tables to be processed.
## In this case, select the required and acceptable columns from the specification csv file.
column_specs<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
# get the specs for tblART
expectednames<-test001[test001$tbl==tablename,]$required_columns
acceptablenames<-test001[test001$tbl==tablename,]$acceptable_columns
}
else if {
expectednames <- c("patient","art_id","art_sd","art_ed","art_rs","art_rs2","art_rs3","art_rs4","art_form","art_comb","artstart_rs")
acceptablenames <- c(expectednames,"art_sd_a","art_ed_a")
}
if (file.exists("./input/Specification_of_required_and_acceptable_columns.csv")) {
## if the Specification file exists tbl_checks.R will only call tblART_checks.R
## when tblART has been specified as being in the set of tables to be processed.
## In this case, select the required and acceptable columns from the specification csv file.
column_specs<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
# get the specs for tblART
expectednames<-test001[test001$tbl==tablename,]$required_columns
acceptablenames<-test001[test001$tbl==tablename,]$acceptable_columns
}
else {
expectednames <- c("patient","art_id","art_sd","art_ed","art_rs","art_rs2","art_rs3","art_rs4","art_form","art_comb","artstart_rs")
acceptablenames <- c(expectednames,"art_sd_a","art_ed_a")
}
expectednames<-test001[test001$tbl==tablename,]$required_columns
acceptablenames<-test001[test001$tbl==tablename,]$acceptable_columns
if (file.exists("./input/Specification_of_required_and_acceptable_columns.csv")) {
## if the Specification file exists tbl_checks.R will only call tblART_checks.R
## when tblART has been specified as being in the set of tables to be processed.
## In this case, select the required and acceptable columns from the specification csv file.
column_specs<-read.table("./input/Specification_of_required_and_acceptable_columns.tsv",header = TRUE, sep="\t", stringsAsFactors=FALSE)
# get the specs for tblART
expectednames<-test001[test001$tbl==tablename,]$required_columns
acceptablenames<-test001[test001$tbl==tablename,]$acceptable_columns
}
else {
expectednames <- c("patient","art_id","art_sd","art_ed","art_rs","art_rs2","art_rs3","art_rs4","art_form","art_comb","artstart_rs")
acceptablenames <- c(expectednames,"art_sd_a","art_ed_a")
}
